# Java实现RPC框架 #

## 1、实现技术方案 ##

用比较原始的方案实现RPC框架，采用Socket通信、动态代理与反射与Java原生的序列化

## 2、RPC框架架构 ##

RPC架构分为三部分：

1）**服务提供者**，运行在服务器端，提供服务接口定义与服务实现类。

2）**服务中心**，运行在服务器端，负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。

3）**服务消费者**，运行在客户端，通过远程代理对象调用远程服务。

![RPC示意图](http://images2015.cnblogs.com/blog/522490/201510/522490-20151003120412386-363334260.png)

    1）服务消费方（client）调用以本地调用方式调用服务；

    2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；

    3）client stub找到服务地址，并将消息发送到服务端；

    4）server stub收到消息后进行解码；

    5）server stub根据解码结果调用本地的服务；

    6）本地服务执行并将结果返回给server stub；

    7）server stub将返回结果打包成消息并发送至消费方；

    8）client stub接收到消息，并进行解码；

    9）服务消费方得到最终结果。

**RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。**

如上图所示，假设Computer1在调用sayHi()方法，对于Computer1而言调用sayHi()方法就像调用本地方法一样，调用 –>返回。但从后续调用可以看出Computer1调用的是Computer2中的sayHi()方法，RPC屏蔽了底层的实现细节，让调用者无需关注网络通信，数据传输等细节。

## 3、RPC框架的实现 ##

上面介绍了RPC的核心原理：**RPC能够让本地应用简单、高效地调用服务器中的过程（服务）**。它主要应用在分布式系统。如Hadoop中的IPC组件。但怎样实现一个RPC框架呢？

从下面几个方面思考，仅供参考：

1.通信模型：假设通信的为A机器与B机器，A与B之间有通信模型，在Java中一般基于BIO或NIO；。

2.过程（服务）定位：使用给定的通信方式，与确定IP与端口及方法名称确定具体的过程或方法；

3.远程代理对象：本地调用的方法(服务)其实是远程方法的本地代理，因此可能需要一个远程代理对象，对于Java而言，远程代理对象可以使用Java的动态对象实现，封装了调用远程方法调用；

4.序列化，将对象名称、方法名称、参数等对象信息进行网络传输需要转换成二进制传输，这里可能需要不同的序列化技术方案。如:protobuf，Arvo等。

> 转载：http://www.cnblogs.com/codingexperience/p/5930752.html